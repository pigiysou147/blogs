import{_ as e,c as i,o as a,b as d}from"./app-BMgFoFFe.js";const r="data:image/svg+xml,%3csvg%20width='760'%20height='473'%20viewBox='0%200%20760%20473'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3crect%20width='760'%20height='473'%20fill='white'/%3e%3crect%20x='236.5'%20y='319.5'%20width='241'%20height='124'%20fill='%23E8F0FE'%20stroke='%233740FF'/%3e%3crect%20x='236.5'%20y='29.5'%20width='241'%20height='124'%20fill='%23E8F0FE'%20stroke='%233740FF'/%3e%3crect%20x='236.5'%20y='174.5'%20width='241'%20height='124'%20fill='%23E8F0FE'%20stroke='%233740FF'/%3e%3crect%20x='507'%20y='88'%20width='6'%20height='276'%20fill='%2300C9DB'/%3e%3cpath%20d='M524%20358H496L510.627%20381L524%20358Z'%20fill='%2300C9DB'/%3e%3c/svg%3e",t="/blogs/assets/a-diagram-the-four-main-0547c6c8ed138-B91DadBI.svg",n="/blogs/assets/the-word-trouble-runnin-645c6ed02703c-CYALktQr.svg",o="data:image/png;base64,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",s="/blogs/assets/a-diagram-representation-5f42dbf13f58c-l8Klw2We.svg",l="/blogs/assets/consistent-spacing-betwee-eb88766a9292e-Cl1xYZHQ.svg",p={},c=d('<h1 id="间距" tabindex="-1"><a class="header-anchor" href="#间距"><span>间距</span></a></h1><p>假设您有一个由三个框组成，这些框堆叠在一起的集合，并且您希望它们之间留有空间。您能想到在 CSS 中通过几种方式来实现这一点？</p><figure><img src="'+r+'" alt="三个堆叠的框和一个向下箭头" tabindex="0" loading="lazy"><figcaption>三个堆叠的框和一个向下箭头</figcaption></figure><p><code>margin</code> 属性或许可以提供您所需的内容，但也可能会添加您不想要的额外间距。例如，如何仅定位上述各元素之间的空间？ 在这种情况下，像 <code>gap</code> 之类的代码可能更合适。您可以通过多种方式调整界面中的间距，每种方式都有自己的优势和注意事项。</p><h2 id="html-间距" tabindex="-1"><a class="header-anchor" href="#html-间距"><span>HTML 间距</span></a></h2><p>HTML 本身提供了一些设置空间元素的方法。 借助 <code>&lt;br&gt; </code> 和 <code>&lt;hr&gt; </code> 元素，您可以在块方向上为元素设置间距。如果您使用的是基于拉丁语的语言，这些方向即为从上到下。</p><p>如果您使用 <code>&lt;br&gt; </code> 元素，它会创建一个换行符，就好比您在文字处理器中按 Enter 键。</p><p><code>&lt;hr&gt;</code> 会创建一条两侧有空格的水平线，称为 <code>margin</code>。</p><iframe allow="camera; clipboard-read; clipboard-write; encrypted-media; geolocation; microphone; midi;" loading="lazy" src="https://codepen.io/web-dot-dev/embed/dyNRJQg?height=500&amp;theme-id=light&amp;default-tab=result&amp;editable=true" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-title="web-dot-dev 上 Codepen 的 Pen dyNRJQg" style="color-scheme:initial;box-sizing:inherit;border:0px;height:500px;width:100%;--darkreader-inline-border-top:0px;--darkreader-inline-border-right:0px;--darkreader-inline-border-bottom:0px;--darkreader-inline-border-left:0px;"></iframe><p>除了使用 HTML 元素，HTML <em>实体</em>也可以创建空间。HTML 实体是浏览器使用字符实体替换的预留字符串。例如，如果您在 HTML 文件中输入 <code>&amp;copy;</code>，系统会将其转换为 © 字符。 <code>&amp;nbsp; </code> 实体会转换为不间断空格字符，以提供内嵌空格。但要小心，这个角色的非破坏性方面会将这两个元素拼接在一起，这可能会导致出现奇怪的行为。</p><p><strong>注意</strong> ：仅当 HTML 元素有助于用户理解文档时，才应使用该元素来增加空间。例如，`` 不只是添加空格，还会创建两个内容块的逻辑分隔。如果您只是想在线条周围添加有空格的线条，那么添加带 CSS 的边框可能更加合适。</p><h2 id="外边距" tabindex="-1"><a class="header-anchor" href="#外边距"><span>外边距</span></a></h2><p>如果要在元素外部增加空间，可以使用 <code>margin</code> 属性。外边距就像在元素周围添加一个缓冲一样。<code>margin</code> 属性是 <code>margin-top</code>、<code>margin-right</code>、<code>margin-bottom</code> 和 <code>margin-left</code> 的简写形式。</p><figure><img src="'+t+'" alt="盒子模型四个主要区域的示意图。" tabindex="0" loading="lazy"><figcaption>盒子模型四个主要区域的示意图。</figcaption></figure><p><code>margin</code> 简写形式以特定顺序应用属性：上、右、下、左。但记不住这么多消息：TRouBLe。</p><figure><img src="'+n+`" alt="单词“Problem”向下延伸，T、R、B 和 L 延伸至顶部、右侧、底部和左侧。一个带有箭头的方框。" tabindex="0" loading="lazy"><figcaption>单词“Problem”向下延伸，T、R、B 和 L 延伸至顶部、右侧、底部和左侧。一个带有箭头的方框。</figcaption></figure><p><code>margin</code> 简写形式也可以与一个、两个或三个值结合使用。通过添加第四个值，您可以设置各个面。具体应用方式如下：</p><ul><li>所有面都会应用一个值。(<code>margin: 20px</code>).</li><li>两个值：第一个值将应用于顶部和底部，第二个值将应用于左侧和右侧。(<code>margin: 20px 40px</code>)</li><li>三个值：第一个值为 <code>top</code>，第二个值为 <code>left</code> 和 <code>right</code>，第三个值为 <code>bottom</code>。(<code>margin: 20px 40px 30px</code>).</li></ul><iframe allow="camera; clipboard-read; clipboard-write; encrypted-media; geolocation; microphone; midi;" loading="lazy" src="https://codepen.io/web-dot-dev/embed/abpwqyQ?height=500&amp;theme-id=light&amp;default-tab=result&amp;editable=true" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-title="由 web-dot-dev 在 Codepen 上撰写的 Pen abpwqyQ" style="color-scheme:initial;box-sizing:inherit;border:0px;height:500px;width:100%;--darkreader-inline-border-top:0px;--darkreader-inline-border-right:0px;--darkreader-inline-border-bottom:0px;--darkreader-inline-border-left:0px;"></iframe><p>可以使用长度、百分比或自动值来定义外边距，例如 <code>1em</code> 或 <code>20%</code>。如果您使用百分比，该值将根据元素所在块的宽度计算得出。</p><p>这意味着，如果元素所在块的宽度为 <code>250px</code>，元素的 <code>margin</code> 值为 <code>20%</code>，则元素每边的计算外边距为 <code>50px</code>。</p><iframe allow="camera; clipboard-read; clipboard-write; encrypted-media; geolocation; microphone; midi;" loading="lazy" src="https://codepen.io/web-dot-dev/embed/YzNQeyb?height=500&amp;theme-id=light&amp;default-tab=result&amp;editable=true" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-title="来自 Codepen 上的 web-dot-dev 的 Pen YzNQeyb" style="color-scheme:initial;box-sizing:inherit;border:0px;height:500px;width:100%;--darkreader-inline-border-top:0px;--darkreader-inline-border-right:0px;--darkreader-inline-border-bottom:0px;--darkreader-inline-border-left:0px;"></iframe><p>您还可以为外边距使用 <code>auto</code> 值。 对于大小受限的块级元素，<code>auto</code> 外边距会在其应用方向上占用可用空间。<a href="/blogs/web/css/flexbox">Flexbox 模块</a>中的这个模块就是一个很好的例子，在该模块中，项会互相推开。</p><iframe allow="camera; clipboard-read; clipboard-write; encrypted-media; geolocation; microphone; midi;" loading="lazy" src="https://codepen.io/web-dot-dev/embed/poRELbR?height=500&amp;theme-id=light&amp;default-tab=result&amp;editable=true" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-title="由 web-dot-dev 在 Codepen 上撰写的 Pen poRELbR" style="color-scheme:initial;box-sizing:inherit;border:0px;height:500px;width:100%;--darkreader-inline-border-top:0px;--darkreader-inline-border-right:0px;--darkreader-inline-border-bottom:0px;--darkreader-inline-border-left:0px;"></iframe><p><code>auto</code> 外边距的另一个典型示例是具有最大宽度的水平居中封装容器。这种封装容器通常用于在网站上创建一致的中心列。</p><div class="language-css line-numbers-mode" data-highlighter="shiki" data-ext="css" data-title="css" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.wrapper</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {  </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    max-width: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">400</span><span style="--shiki-light:#986801;--shiki-dark:#E06C75;">px</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;  </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    margin: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#D19A66;"> auto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><iframe allow="camera; clipboard-read; clipboard-write; encrypted-media; geolocation; microphone; midi;" loading="lazy" src="https://codepen.io/web-dot-dev/embed/XWpgZKq?height=500&amp;theme-id=light&amp;default-tab=result&amp;editable=true" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-title="来自 Codepen 上的 web-dot-dev 的 Pen XWpgZKq" style="color-scheme:initial;box-sizing:inherit;border:0px;height:500px;width:100%;--darkreader-inline-border-top:0px;--darkreader-inline-border-right:0px;--darkreader-inline-border-bottom:0px;--darkreader-inline-border-left:0px;"></iframe><p>在此示例中，从顶部和底部（块）两侧移除了外边距，<code>auto</code> 共享左侧和右侧（内嵌）之间的空间。</p><p><strong>注意</strong> ：在前面介绍<a href="/blogs/web/css/logical-properties">逻辑属性</a>的单元中，您了解到可以使用 <code>margin-block-start</code>、<code>margin-inline-end</code>、<code>margin-block-end</code> 和 <code>margin-inline-start</code>，而无需指定 <code>margin-top</code>、<code>margin-right</code>、<code>margin-bottom</code> 和 <code>margin-left</code>。</p><h3 id="负值外边距" tabindex="-1"><a class="header-anchor" href="#负值外边距"><span>负值外边距</span></a></h3><p>负值也可用于外边距。 系统不会在相邻的同级元素之间添加空间，而是<strong>减少它们之间的空间</strong>。如果您声明的负值大于可用空间，可能会导致元素重叠。</p><iframe allow="camera; clipboard-read; clipboard-write; encrypted-media; geolocation; microphone; midi;" loading="lazy" src="https://codepen.io/web-dot-dev/embed/YzNQeLP?height=500&amp;theme-id=light&amp;default-tab=result&amp;editable=true" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-title="由 web-dot-dev 在 Codepen 上开发的 Pen YzNQeLP" style="color-scheme:initial;box-sizing:inherit;border:0px;height:500px;width:100%;--darkreader-inline-border-top:0px;--darkreader-inline-border-right:0px;--darkreader-inline-border-bottom:0px;--darkreader-inline-border-left:0px;"></iframe><h3 id="外边距折叠" tabindex="-1"><a class="header-anchor" href="#外边距折叠"><span>外边距折叠</span></a></h3><p>外边距折叠是一个棘手的概念，但在构建接口时经常会遇到这个问题。假设您有两个元素：标题和段落上都有垂直外边距：</p><div class="language-html line-numbers-mode" data-highlighter="shiki" data-ext="html" data-title="html" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">article</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">h1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;My heading with teal margin&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">h1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;A paragraph of text that has blue margin on it, following the heading with margin.&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">article</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">h1 {   </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">	margin-bottom: 2rem;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">p { </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">	margin-top: 3rem;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><iframe allow="camera; clipboard-read; clipboard-write; encrypted-media; geolocation; microphone; midi;" loading="lazy" src="https://codepen.io/web-dot-dev/embed/OJWgvMx?height=500&amp;theme-id=light&amp;default-tab=result&amp;editable=true" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-title="web-dot-dev 上 Codepen 的 Pen OJWgvMx" style="color-scheme:initial;box-sizing:inherit;border:0px;height:500px;width:100%;--darkreader-inline-border-top:0px;--darkreader-inline-border-right:0px;--darkreader-inline-border-bottom:0px;--darkreader-inline-border-left:0px;"></iframe><p>乍一看，您也许以为段落与标题之间以 <code>5em</code> 为间隔，因为 <code>2rem</code> 和 <code>3rem</code> 的总和计算为 <code>5rem</code>。不过，由于<strong>垂直外边距会收起</strong>，因此该空间实际上为 <code>3rem</code>。</p><p>外边距收起的工作原理是，选择两个相邻元素的最大值，并在相邻的两侧设置垂直外边距。<code>h1</code> 的下外边距与 <code>p</code> 的顶部交汇，因此选择 <code>h1</code> 的下外边距和 <code>p</code> 的上外边距的最大值。如果 <code>h1</code> 的下外边距为 <code>3.5rem</code>，则两者之间的间距将为 <code>3.5rem</code>，因为它大于 <code>3rem</code>。只有块外边距会收起，不会内嵌（水平）外边距。</p><p><strong>注意</strong> ：这种行为根植于当网络大多只是文档时。折叠外边距有助于在元素之间设置一致的间距，而不会意外在已定义外边距的元素之间产生巨大的间隙。</p><p>外边距收起也有助于处理空元素。 如果您的某个段落的上外边距和下外边距为 <code>20px</code>，则该段落将仅创建 <code>20px</code> 的空间，而不是 <code>40px</code>。 不过，如果此元素内部添加了<em>任何内容</em>（包括 <code>padding</code>），其外边距将不再自行收起，并会被视为任何包含内容的框。</p><h4 id="防止外边距合拢" tabindex="-1"><a class="header-anchor" href="#防止外边距合拢"><span>防止外边距合拢</span></a></h4><p>如果您使用 <code>position: absolute</code> 将某个元素设置为绝对定位，则外边距将不再收起。如果您还使用 <code>float</code> 属性，则外边距也不会折叠。</p><p>如果您的某个元素在采用块外边距的两个元素之间没有外边距，那么外边距也不会折叠，因为这两个有块外边距的元素不再是相邻的同级元素：它们只是同级。</p><iframe allow="camera; clipboard-read; clipboard-write; encrypted-media; geolocation; microphone; midi;" loading="lazy" src="https://codepen.io/web-dot-dev/embed/YzNQavQ?height=500&amp;theme-id=light&amp;default-tab=result&amp;editable=true" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-title="由 web-dot-dev 在 Codepen 上开发的 Pen YzNQavQ" style="color-scheme:initial;box-sizing:inherit;border:0px;height:500px;width:100%;--darkreader-inline-border-top:0px;--darkreader-inline-border-right:0px;--darkreader-inline-border-bottom:0px;--darkreader-inline-border-left:0px;"></iframe><p>在<a href="/blogs/web/css/layout">布局课程</a>中，您已了解 Flexbox 容器和网格容器与块容器非常相似，但处理其子元素的方式截然不同。外边距收起的情况也是如此。</p><p>如果我们使用本课程中的原始示例，并通过列方向应用 Flexbox，则外边距会合并，而不是收起。 这可以通过布局工作实现可预测性，这正是 Flexbox 和网格容器的设计目标。</p><iframe allow="camera; clipboard-read; clipboard-write; encrypted-media; geolocation; microphone; midi;" loading="lazy" src="https://codepen.io/web-dot-dev/embed/QWdgmNx?height=500&amp;theme-id=light&amp;default-tab=result&amp;editable=true" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-title="由 web-dot-dev 在 Codepen 上开发的 Pen QWdgmNx" style="color-scheme:initial;box-sizing:inherit;border:0px;height:500px;width:100%;--darkreader-inline-border-top:0px;--darkreader-inline-border-right:0px;--darkreader-inline-border-bottom:0px;--darkreader-inline-border-left:0px;"></iframe><p>外边距和外边距折叠可能难以理解，但详细了解它们的工作原理非常有用，因此强烈建议您使用<a href="https://www.smashingmagazine.com/2019/07/margins-in-css" target="_blank" rel="noopener noreferrer">这篇详细的解释器</a>。</p><h2 id="内边距" tabindex="-1"><a class="header-anchor" href="#内边距"><span>内边距</span></a></h2><p><code>padding</code>属性会在盒子的<strong>内部</strong>内部创建空间，而不是像<code>margin</code>那样在盒子的外侧留出空间，而是采取隔热措施。</p><figure><img src="`+o+'" alt="一个带有向内箭头的框，表示内边距位于框内" tabindex="0" loading="lazy"><figcaption>一个带有向内箭头的框，表示内边距位于框内</figcaption></figure><p><code>padding</code> 也可能影响元素的总体尺寸，具体取决于您使用的框模型（我们在<a href="/blogs/web/css/box-model">框模型课程</a>中对此进行了介绍）。</p><iframe allow="camera; clipboard-read; clipboard-write; encrypted-media; geolocation; microphone; midi;" loading="lazy" src="https://codepen.io/web-dot-dev/embed/eYgRrzz?height=500&amp;theme-id=light&amp;default-tab=result&amp;editable=true" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-title="Codepen 上 web-dot-dev 的 Pen eYgRrzz" style="color-scheme:initial;box-sizing:inherit;border:0px;height:500px;width:100%;--darkreader-inline-border-top:0px;--darkreader-inline-border-right:0px;--darkreader-inline-border-bottom:0px;--darkreader-inline-border-left:0px;"></iframe><p><code>padding</code> 属性是 <code>padding-top</code>、<code>padding-right</code>、<code>padding-bottom</code> 和 <code>padding-left</code> 的简写形式。与 <code>margin</code> 一样，<code>padding</code> 也具有逻辑属性：<code>padding-block-start</code>、<code>padding-inline-end</code>、<code>padding-block-end</code> 和 <code>padding-inline-start</code>。</p><h2 id="positioning" tabindex="-1"><a class="header-anchor" href="#positioning"><span>Positioning</span></a></h2><p>同样，<a href="/blogs/web/css/layout">layout</a> 模块中也对此进行了介绍，如果您为 <code>position</code> 设置的值是 <code>static</code> 以外的任何值，则可以使用 <code>top</code>、<code>right</code>、<code>bottom</code> 和 <code>left</code> 属性来设置元素间距。这些方向值的行为方式存在一些差异：</p><ul><li>具有 <code>position: relative</code> 的元素将保持其在文档流中的位置，即使您设置了这些值也是如此。它们还会以元素的位置为参照物。</li><li>具有 <code>position: absolute</code> 的元素将基于相对父项的位置建立方向值。</li><li>具有 <code>position: fixed</code> 的元素将基于视口来确定方向值。</li><li>具有 <code>position: sticky</code> 的元素仅在处于停靠/卡住状态时才应用方向值。</li></ul><iframe allow="camera; clipboard-read; clipboard-write; encrypted-media; geolocation; microphone; midi;" loading="lazy" src="https://codepen.io/web-dot-dev/embed/NWdNGZB?height=500&amp;theme-id=light&amp;default-tab=result&amp;editable=true" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-title="由 web-dot-dev 在 Codepen 上的 Pen NWdNGZB" style="color-scheme:initial;box-sizing:inherit;border:0px;height:500px;width:100%;--darkreader-inline-border-top:0px;--darkreader-inline-border-right:0px;--darkreader-inline-border-bottom:0px;--darkreader-inline-border-left:0px;"></iframe><p>在<a href="/blogs/web/css/logical-properties">逻辑属性</a>模块中，您将了解 <code>inset-block</code> 和 <code>inset-inline</code> 属性，这两个属性可用于设置遵循写入模式的方向值。</p><p>这两个属性都是组合了 <code>start</code> 和 <code>end</code> 值的简写形式，因此可以接受为 <code>start</code> 和 <code>end</code> 设置的一个值或两个单独的值。</p><h2 id="网格和-flexbox" tabindex="-1"><a class="header-anchor" href="#网格和-flexbox"><span>网格和 Flexbox</span></a></h2><p>最后，在网格和 Flexbox 中，您可以使用 <code>gap</code> 属性在子元素之间创建空间。 <code>gap</code> 属性是 <code>row-gap</code> 和 <code>column-gap</code> 的简写形式，它接受一个或两个值，可以是长度或百分比。您也可以使用 <code>unset</code>、<code>initial</code> 和 <code>inherit</code> 等关键字。如果您只定义一个值，则相同的 <code>gap</code> 将同时应用于行和列，但如果您同时定义了这两个值，则第一个值为 <code>row-gap</code>，第二个值为 <code>column-gap</code>。</p><p>借助 Flexbox 和网格，您还可以使用其分布和对齐功能创建空间，<a href="/blogs/web/css/grid">网格模块</a>和 <a href="/blogs/web/css/flexbox">Flexbox 模块</a>对此进行了介绍。</p><figure><img src="'+s+'" alt="带有间隙的网格的示意图" tabindex="0" loading="lazy"><figcaption>带有间隙的网格的示意图</figcaption></figure><h2 id="创建一致的间距" tabindex="-1"><a class="header-anchor" href="#创建一致的间距"><span>创建一致的间距</span></a></h2><p>选择并坚持采用这种策略是个不错的选择，可以帮助您创建具有良好流程和节奏的一致界面。为实现这一目标，一种好方法是使用一致的间距度量。</p><p>例如，您可以承诺使用 <code>20px</code> 作为元素之间所有间隙（称为边线）的一致衡量方式，以使所有布局的外观和风格保持一致。您还可以决定使用 <code>1em</code> 作为数据流内容之间的垂直间距，这样便可根据元素的 <code>font-size</code> 实现一致的间距。无论您选择哪种类型，都应该将这些值保存为变量（或 CSS 自定义属性），以便对这些值进行标记化，并简化一致性。</p><figure><img src="'+l+`" alt="元素之间的间距一致，对布局使用 20px，对数据流内容使用 1em。" tabindex="0" loading="lazy"><figcaption>元素之间的间距一致，对布局使用 20px，对数据流内容使用 1em。</figcaption></figure><div class="language-css line-numbers-mode" data-highlighter="shiki" data-ext="css" data-title="css" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#986801;--shiki-dark:#56B6C2;">:root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    --gutter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">20</span><span style="--shiki-light:#986801;--shiki-dark:#E06C75;">px</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;  </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">--spacing</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#986801;--shiki-dark:#E06C75;">em</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">h1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    margin-left: </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">var</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">--gutter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    margin-top: </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">var</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">--spacing</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用此类自定义属性时，您只需定义一次，然后便可在整个 CSS 中使用它们。当更新值时，无论是在元素本地更新还是全局更新，值将通过级联传递并反映更新后的值。</p>`,70),h=[c];function g(m,b){return a(),i("div",null,h)}const f=e(p,[["render",g],["__file","spacing.html.vue"]]),A=JSON.parse('{"path":"/web/css/spacing.html","title":"间距","lang":"zh-CN","frontmatter":{"date":"2024-03-31T00:00:00.000Z","category":"css","tags":["盒子模型"],"description":"间距 假设您有一个由三个框组成，这些框堆叠在一起的集合，并且您希望它们之间留有空间。您能想到在 CSS 中通过几种方式来实现这一点？ 三个堆叠的框和一个向下箭头三个堆叠的框和一个向下箭头 margin 属性或许可以提供您所需的内容，但也可能会添加您不想要的额外间距。例如，如何仅定位上述各元素之间的空间？ 在这种情况下，像 gap 之类的代码可能更合适。...","head":[["meta",{"property":"og:url","content":"https://pigiysou147.github.io/blogs/web/css/spacing.html"}],["meta",{"property":"og:site_name","content":"silly blogs"}],["meta",{"property":"og:title","content":"间距"}],["meta",{"property":"og:description","content":"间距 假设您有一个由三个框组成，这些框堆叠在一起的集合，并且您希望它们之间留有空间。您能想到在 CSS 中通过几种方式来实现这一点？ 三个堆叠的框和一个向下箭头三个堆叠的框和一个向下箭头 margin 属性或许可以提供您所需的内容，但也可能会添加您不想要的额外间距。例如，如何仅定位上述各元素之间的空间？ 在这种情况下，像 gap 之类的代码可能更合适。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-24T10:18:51.000Z"}],["meta",{"property":"article:author","content":"Silly"}],["meta",{"property":"article:tag","content":"盒子模型"}],["meta",{"property":"article:published_time","content":"2024-03-31T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-24T10:18:51.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"间距\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-31T00:00:00.000Z\\",\\"dateModified\\":\\"2024-08-24T10:18:51.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Silly\\",\\"url\\":\\"https://pigiysou147.com\\"}]}"]]},"headers":[{"level":2,"title":"HTML 间距","slug":"html-间距","link":"#html-间距","children":[]},{"level":2,"title":"外边距","slug":"外边距","link":"#外边距","children":[{"level":3,"title":"负值外边距","slug":"负值外边距","link":"#负值外边距","children":[]},{"level":3,"title":"外边距折叠","slug":"外边距折叠","link":"#外边距折叠","children":[]}]},{"level":2,"title":"内边距","slug":"内边距","link":"#内边距","children":[]},{"level":2,"title":"Positioning","slug":"positioning","link":"#positioning","children":[]},{"level":2,"title":"网格和 Flexbox","slug":"网格和-flexbox","link":"#网格和-flexbox","children":[]},{"level":2,"title":"创建一致的间距","slug":"创建一致的间距","link":"#创建一致的间距","children":[]}],"git":{"createdTime":1724483645000,"updatedTime":1724494731000,"contributors":[{"name":"方勇","email":"silly@digitalgd.com.cn","commits":2}]},"readingTime":{"minutes":12.8,"words":3839},"filePathRelative":"web/css/spacing.md","localizedDate":"2024年3月31日","excerpt":"\\n<p>假设您有一个由三个框组成，这些框堆叠在一起的集合，并且您希望它们之间留有空间。您能想到在 CSS 中通过几种方式来实现这一点？</p>\\n<figure><figcaption>三个堆叠的框和一个向下箭头</figcaption></figure>\\n<p><code>margin</code> 属性或许可以提供您所需的内容，但也可能会添加您不想要的额外间距。例如，如何仅定位上述各元素之间的空间？ 在这种情况下，像 <code>gap</code> 之类的代码可能更合适。您可以通过多种方式调整界面中的间距，每种方式都有自己的优势和注意事项。</p>\\n<h2>HTML 间距</h2>\\n<p>HTML 本身提供了一些设置空间元素的方法。 借助 <code>&lt;br&gt; </code> 和 <code>&lt;hr&gt; </code> 元素，您可以在块方向上为元素设置间距。如果您使用的是基于拉丁语的语言，这些方向即为从上到下。</p>","autoDesc":true}');export{f as comp,A as data};
