import{_ as s,c as e,o as n,b as a}from"./app-BMgFoFFe.js";const i={},l=a(`<h1 id="node-js-docker容器中线程创建失败" tabindex="-1"><a class="header-anchor" href="#node-js-docker容器中线程创建失败"><span>Node.js Docker容器中线程创建失败</span></a></h1><h2 id="问题背景" tabindex="-1"><a class="header-anchor" href="#问题背景"><span>问题背景</span></a></h2><p>在部署Node.js应用程序到Docker容器时，遇到了一个奇怪的问题。Node.js进程崩溃并且抛出了一个原生堆栈跟踪（native stack trace），显示了一个断言失败，这表明在创建worker线程时遇到了问题。具体的错误信息如下：</p><div class="language-plaintext line-numbers-mode" data-highlighter="shiki" data-ext="plaintext" data-title="plaintext" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Native stack trace</span></span>
<span class="line"><span>1:0xcbc9a7 node::Assert(node::AssertionInfo const&amp;)[node]</span></span>
<span class="line"><span>T</span></span>
<span class="line"><span>0xd3c44e node :: WorkerThreadsTaskRunner ::WorkerThreadsTaskRunner( int) 「node?</span></span>
<span class="line"><span>3</span></span>
<span class="line"><span>0xd3c52c node .: NodePlatform :: NodePlatform( int, v8 :.Tracingcontroller*, v8 :: PageAllocator*) [node]</span></span>
<span class="line"><span>4·</span></span>
<span class="line"><span>0xc707d7 [node</span></span>
<span class="line"><span>5.</span></span>
<span class="line"><span>0xc71d34 node::Start(int, char**)[node]</span></span>
<span class="line"><span>6:0x7f0c7244c24a</span></span>
<span class="line"><span>[/lib/x86_64-linux-gnu/libc.so.6]</span></span>
<span class="line"><span>7:0x7f0c7244c305</span></span>
<span class="line"><span>libc start main [/lib/x86 64-linux-gnu/libc.so.6]</span></span>
<span class="line"><span>8:0xbc6b6e start [node]</span></span>
<span class="line"><span>../src/node platform.cc:68</span></span>
<span class="line"><span>#node[1]: std:: unigue ptr&lt;long unsigned int&gt; node :: workerThreadsTaskRunner :: DelayedTaskscheduler : start() at</span></span>
<span class="line"><span>Assertion failed:(0)=(uv_thread_create(t.get(), start_thread, this))</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个错误发生的位置是在Node.js的内部实现中，具体是在<code>node::WorkerThreadsTaskRunner::DelayedTaskScheduler::start()</code>函数中。错误消息表明<code>uv_thread_create()</code>函数未能成功创建线程。</p><h2 id="分析过程" tabindex="-1"><a class="header-anchor" href="#分析过程"><span>分析过程</span></a></h2><h3 id="线程创建失败的原因" tabindex="-1"><a class="header-anchor" href="#线程创建失败的原因"><span>线程创建失败的原因</span></a></h3><p>通常情况下，这样的错误可能由多种原因引起，包括但不限于内存不足、操作系统级别的限制或者Docker容器的安全策略限制等。在深入调查之后，我们发现这个特定的问题是由Docker容器的资源限制所导致的。</p><h3 id="资源限制与seccomp" tabindex="-1"><a class="header-anchor" href="#资源限制与seccomp"><span>资源限制与Seccomp</span></a></h3><p>Docker通过名为Seccomp的安全机制来限制容器内的进程能够执行哪些系统调用。默认情况下，Seccomp配置会阻止一些不安全的系统调用，而这些调用对于Node.js的应用程序来说可能是必要的。在这种情况下，<code>uv_thread_create()</code>调用可能被阻止了，从而导致了上述错误。</p><h2 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案"><span>解决方案</span></a></h2><p>为了解决这个问题，我们需要允许容器执行所有必需的系统调用。可以通过向<code>docker run</code>命令添加<code>--security-opt seccomp=unconfined</code>参数来实现这一点。这会告诉Docker不要对容器应用任何Seccomp策略，从而允许所有的系统调用。</p><h3 id="修改后的docker-run命令" tabindex="-1"><a class="header-anchor" href="#修改后的docker-run命令"><span>修改后的<code>docker run</code>命令</span></a></h3><p>修改后的<code>docker run</code>命令如下所示：</p><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" data-title="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> run</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --security-opt</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> seccomp=unconfined</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">other</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> option</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">s&gt; &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">image</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> nam</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">e&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>docker compose写法如下：</p><div class="language-yaml line-numbers-mode" data-highlighter="shiki" data-ext="yaml" data-title="yaml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">security_opt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:    - </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">seccomp=unconfined</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="应用示例" tabindex="-1"><a class="header-anchor" href="#应用示例"><span>应用示例</span></a></h3><p>假设我们的Node.js应用程序镜像名称为<code>my-node-app</code>，并且我们已经定义了一些其他的运行选项（例如端口映射），则完整的<code>docker run</code>命令可能看起来像这样：</p><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" data-title="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> run</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --security-opt</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> seccomp=unconfined</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -p</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 8080:8080</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> my-node-app</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="结论" tabindex="-1"><a class="header-anchor" href="#结论"><span>结论</span></a></h2><p>通过这种方式，我们可以绕过Seccomp的限制，确保Node.js应用程序能够在Docker容器内正常运行。虽然这解决了当前的问题，但是需要注意的是，禁用Seccomp可能会增加容器的安全风险。因此，在生产环境中，我们建议仅在必要时才使用这种方法，并考虑更细粒度地控制Seccomp策略以满足应用程序的需求，同时保持一定的安全性。</p><p>详细参考官方文档：https://docs.docker.com/engine/security/seccomp/</p>`,23),t=[l];function d(r,c){return n(),e("div",null,t)}const o=s(i,[["render",d],["__file","Nodejs Docker容器中线程创建失败.html.vue"]]),h=JSON.parse('{"path":"/posts/node/Nodejs%20Docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%A4%B1%E8%B4%A5.html","title":"Node.js Docker容器中线程创建失败","lang":"zh-CN","frontmatter":{"date":"2024-07-04T00:00:00.000Z","category":"nodejs","tags":["docker","报错","thread"],"description":"Node.js Docker容器中线程创建失败 问题背景 在部署Node.js应用程序到Docker容器时，遇到了一个奇怪的问题。Node.js进程崩溃并且抛出了一个原生堆栈跟踪（native stack trace），显示了一个断言失败，这表明在创建worker线程时遇到了问题。具体的错误信息如下： 这个错误发生的位置是在Node.js的内部实现中，...","head":[["meta",{"property":"og:url","content":"https://pigiysou147.github.io/blogs/posts/node/Nodejs%20Docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%A4%B1%E8%B4%A5.html"}],["meta",{"property":"og:site_name","content":"silly blogs"}],["meta",{"property":"og:title","content":"Node.js Docker容器中线程创建失败"}],["meta",{"property":"og:description","content":"Node.js Docker容器中线程创建失败 问题背景 在部署Node.js应用程序到Docker容器时，遇到了一个奇怪的问题。Node.js进程崩溃并且抛出了一个原生堆栈跟踪（native stack trace），显示了一个断言失败，这表明在创建worker线程时遇到了问题。具体的错误信息如下： 这个错误发生的位置是在Node.js的内部实现中，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-24T07:14:05.000Z"}],["meta",{"property":"article:author","content":"Silly"}],["meta",{"property":"article:tag","content":"docker"}],["meta",{"property":"article:tag","content":"报错"}],["meta",{"property":"article:tag","content":"thread"}],["meta",{"property":"article:published_time","content":"2024-07-04T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-24T07:14:05.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Node.js Docker容器中线程创建失败\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-07-04T00:00:00.000Z\\",\\"dateModified\\":\\"2024-08-24T07:14:05.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Silly\\",\\"url\\":\\"https://pigiysou147.com\\"}]}"]]},"headers":[{"level":2,"title":"问题背景","slug":"问题背景","link":"#问题背景","children":[]},{"level":2,"title":"分析过程","slug":"分析过程","link":"#分析过程","children":[{"level":3,"title":"线程创建失败的原因","slug":"线程创建失败的原因","link":"#线程创建失败的原因","children":[]},{"level":3,"title":"资源限制与Seccomp","slug":"资源限制与seccomp","link":"#资源限制与seccomp","children":[]}]},{"level":2,"title":"解决方案","slug":"解决方案","link":"#解决方案","children":[{"level":3,"title":"修改后的docker run命令","slug":"修改后的docker-run命令","link":"#修改后的docker-run命令","children":[]},{"level":3,"title":"应用示例","slug":"应用示例","link":"#应用示例","children":[]}]},{"level":2,"title":"结论","slug":"结论","link":"#结论","children":[]}],"git":{"createdTime":1724483645000,"updatedTime":1724483645000,"contributors":[{"name":"方勇","email":"silly@digitalgd.com.cn","commits":1}]},"readingTime":{"minutes":2.55,"words":764},"filePathRelative":"posts/node/Nodejs Docker容器中线程创建失败.md","localizedDate":"2024年7月4日","excerpt":"\\n<h2>问题背景</h2>\\n<p>在部署Node.js应用程序到Docker容器时，遇到了一个奇怪的问题。Node.js进程崩溃并且抛出了一个原生堆栈跟踪（native stack trace），显示了一个断言失败，这表明在创建worker线程时遇到了问题。具体的错误信息如下：</p>\\n<div class=\\"language-plaintext line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"plaintext\\" data-title=\\"plaintext\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>Native stack trace</span></span>\\n<span class=\\"line\\"><span>1:0xcbc9a7 node::Assert(node::AssertionInfo const&amp;)[node]</span></span>\\n<span class=\\"line\\"><span>T</span></span>\\n<span class=\\"line\\"><span>0xd3c44e node :: WorkerThreadsTaskRunner ::WorkerThreadsTaskRunner( int) 「node?</span></span>\\n<span class=\\"line\\"><span>3</span></span>\\n<span class=\\"line\\"><span>0xd3c52c node .: NodePlatform :: NodePlatform( int, v8 :.Tracingcontroller*, v8 :: PageAllocator*) [node]</span></span>\\n<span class=\\"line\\"><span>4·</span></span>\\n<span class=\\"line\\"><span>0xc707d7 [node</span></span>\\n<span class=\\"line\\"><span>5.</span></span>\\n<span class=\\"line\\"><span>0xc71d34 node::Start(int, char**)[node]</span></span>\\n<span class=\\"line\\"><span>6:0x7f0c7244c24a</span></span>\\n<span class=\\"line\\"><span>[/lib/x86_64-linux-gnu/libc.so.6]</span></span>\\n<span class=\\"line\\"><span>7:0x7f0c7244c305</span></span>\\n<span class=\\"line\\"><span>libc start main [/lib/x86 64-linux-gnu/libc.so.6]</span></span>\\n<span class=\\"line\\"><span>8:0xbc6b6e start [node]</span></span>\\n<span class=\\"line\\"><span>../src/node platform.cc:68</span></span>\\n<span class=\\"line\\"><span>#node[1]: std:: unigue ptr&lt;long unsigned int&gt; node :: workerThreadsTaskRunner :: DelayedTaskscheduler : start() at</span></span>\\n<span class=\\"line\\"><span>Assertion failed:(0)=(uv_thread_create(t.get(), start_thread, this))</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{o as comp,h as data};
